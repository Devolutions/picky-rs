// <auto-generated/> by Diplomat

#pragma warning disable 0105
using System;
using System.Runtime.InteropServices;

using Devolutions.Picky.Diplomat;
#pragma warning restore 0105

namespace Devolutions.Picky;

#nullable enable

/// <summary>
/// PuTTY Private Key (PPK) format.
/// </summary>
/// <remarks>
/// ### Functionality
/// - Generation of new keys.
/// - Conversion to/from OpenSSH format.
/// - Encoding/decoding to/from string.
/// - Version upgrade/downgrade.
/// <br/>
/// ### Usage notes
/// - Ppk structure is immutable. All operations that modify the key return a new instance.
/// - When input file is encrypted, all operations with the private key will be unavailable until
/// ppk is decrypted via `PuttyPpk::decrypt`.
/// - Newly generated keys are always unencrypted. They should be encrypted via `PuttyPpk::encrypt`
/// when required
/// </remarks>
public partial class PuttyPpk: IDisposable
{
    private unsafe Raw.PuttyPpk* _inner;

    public PuttyPpkKeyAlgorithm Algorithm
    {
        get
        {
            return GetAlgorithm();
        }
    }

    public string Comment
    {
        get
        {
            return GetComment();
        }
    }

    public PrivateKey PrivateKey
    {
        get
        {
            return GetPrivateKey();
        }
    }

    public PublicKey PublicKey
    {
        get
        {
            return GetPublicKey();
        }
    }

    public PuttyPpkVersion Version
    {
        get
        {
            return GetVersion();
        }
    }

    /// <summary>
    /// Creates a managed <c>PuttyPpk</c> from a raw handle.
    /// </summary>
    /// <remarks>
    /// Safety: you should not build two managed objects using the same raw handle (may causes use-after-free and double-free).
    /// <br/>
    /// This constructor assumes the raw struct is allocated on Rust side.
    /// If implemented, the custom Drop implementation on Rust side WILL run on destruction.
    /// </remarks>
    public unsafe PuttyPpk(Raw.PuttyPpk* handle)
    {
        _inner = handle;
    }

    /// <summary>
    /// Generate a new RSA key file.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PuttyPpk</c> allocated on Rust side.
    /// </returns>
    public static PuttyPpk GenerateRsa(nuint bits, string comment)
    {
        unsafe
        {
            byte[] commentBuf = DiplomatUtils.StringToUtf8(comment);
            nuint commentBufLength = (nuint)commentBuf.Length;
            fixed (byte* commentBufPtr = commentBuf)
            {
                IntPtr resultPtr = Raw.PuttyPpk.GenerateRsa(bits, commentBufPtr, commentBufLength);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError>(resultPtr);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError.Destroy(resultPtr);
                if (!result.isOk)
                {
                    throw new PickyException(new PickyError(result.Err));
                }
                Raw.PuttyPpk* retVal = result.Ok;
                return new PuttyPpk(retVal);
            }
        }
    }

    /// <summary>
    /// Generate a new EC key file.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PuttyPpk</c> allocated on Rust side.
    /// </returns>
    public static PuttyPpk GenerateEc(EcCurve curve, string comment)
    {
        unsafe
        {
            byte[] commentBuf = DiplomatUtils.StringToUtf8(comment);
            nuint commentBufLength = (nuint)commentBuf.Length;
            Raw.EcCurve curveRaw;
            curveRaw = (Raw.EcCurve)curve;
            fixed (byte* commentBufPtr = commentBuf)
            {
                IntPtr resultPtr = Raw.PuttyPpk.GenerateEc(curveRaw, commentBufPtr, commentBufLength);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError>(resultPtr);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError.Destroy(resultPtr);
                if (!result.isOk)
                {
                    throw new PickyException(new PickyError(result.Err));
                }
                Raw.PuttyPpk* retVal = result.Ok;
                return new PuttyPpk(retVal);
            }
        }
    }

    /// <summary>
    /// Generate a new Ed25519 key file.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PuttyPpk</c> allocated on Rust side.
    /// </returns>
    public static PuttyPpk GenerateEd25519(string comment)
    {
        unsafe
        {
            byte[] commentBuf = DiplomatUtils.StringToUtf8(comment);
            nuint commentBufLength = (nuint)commentBuf.Length;
            fixed (byte* commentBufPtr = commentBuf)
            {
                IntPtr resultPtr = Raw.PuttyPpk.GenerateEd25519(commentBufPtr, commentBufLength);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError>(resultPtr);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError.Destroy(resultPtr);
                if (!result.isOk)
                {
                    throw new PickyException(new PickyError(result.Err));
                }
                Raw.PuttyPpk* retVal = result.Ok;
                return new PuttyPpk(retVal);
            }
        }
    }

    /// <summary>
    /// Encode PPK key file to a string.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    public void ToRepr(DiplomatWriteable writeable)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            IntPtr resultPtr = Raw.PuttyPpk.ToRepr(_inner, &writeable);
            Raw.PuttyFfiResultVoidBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultVoidBoxPickyError>(resultPtr);
            Raw.PuttyFfiResultVoidBoxPickyError.Destroy(resultPtr);
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
        }
    }

    /// <summary>
    /// Encode PPK key file to a string.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    public string ToRepr()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            DiplomatWriteable writeable = new DiplomatWriteable();
            IntPtr resultPtr = Raw.PuttyPpk.ToRepr(_inner, &writeable);
            Raw.PuttyFfiResultVoidBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultVoidBoxPickyError>(resultPtr);
            Raw.PuttyFfiResultVoidBoxPickyError.Destroy(resultPtr);
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
            string retVal = writeable.ToUnicode();
            writeable.Dispose();
            return retVal;
        }
    }

    /// <summary>
    /// Parse a PPK key file from a string.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PuttyPpk</c> allocated on Rust side.
    /// </returns>
    public static PuttyPpk Parse(string ppk)
    {
        unsafe
        {
            byte[] ppkBuf = DiplomatUtils.StringToUtf8(ppk);
            nuint ppkBufLength = (nuint)ppkBuf.Length;
            fixed (byte* ppkBufPtr = ppkBuf)
            {
                IntPtr resultPtr = Raw.PuttyPpk.Parse(ppkBufPtr, ppkBufLength);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError>(resultPtr);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError.Destroy(resultPtr);
                if (!result.isOk)
                {
                    throw new PickyException(new PickyError(result.Err));
                }
                Raw.PuttyPpk* retVal = result.Ok;
                return new PuttyPpk(retVal);
            }
        }
    }

    /// <summary>
    /// Convert an OpenSSH private key to a PPK key file.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PuttyPpk</c> allocated on Rust side.
    /// </returns>
    public static PuttyPpk FromOpensshPrivateKey(SshPrivateKey key)
    {
        unsafe
        {
            Raw.SshPrivateKey* keyRaw;
            keyRaw = key.AsFFI();
            if (keyRaw == null)
            {
                throw new ObjectDisposedException("SshPrivateKey");
            }
            IntPtr resultPtr = Raw.PuttyPpk.FromOpensshPrivateKey(keyRaw);
            Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError>(resultPtr);
            Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError.Destroy(resultPtr);
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
            Raw.PuttyPpk* retVal = result.Ok;
            return new PuttyPpk(retVal);
        }
    }

    /// <summary>
    /// Convert a PPK key file to an OpenSSH private key.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>SshPrivateKey</c> allocated on Rust side.
    /// </returns>
    public SshPrivateKey ToOpensshPrivateKey(string passphrase)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            byte[] passphraseBuf = DiplomatUtils.StringToUtf8(passphrase);
            nuint passphraseBufLength = (nuint)passphraseBuf.Length;
            fixed (byte* passphraseBufPtr = passphraseBuf)
            {
                IntPtr resultPtr = Raw.PuttyPpk.ToOpensshPrivateKey(_inner, passphraseBufPtr, passphraseBufLength);
                Raw.PuttyFfiResultBoxSshPrivateKeyBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxSshPrivateKeyBoxPickyError>(resultPtr);
                Raw.PuttyFfiResultBoxSshPrivateKeyBoxPickyError.Destroy(resultPtr);
                if (!result.isOk)
                {
                    throw new PickyException(new PickyError(result.Err));
                }
                Raw.SshPrivateKey* retVal = result.Ok;
                return new SshPrivateKey(retVal);
            }
        }
    }

    /// <summary>
    /// Get the public key from the PPK key file.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PublicKey</c> allocated on Rust side.
    /// </returns>
    public PublicKey GetPublicKey()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            IntPtr resultPtr = Raw.PuttyPpk.GetPublicKey(_inner);
            Raw.PuttyFfiResultBoxPublicKeyBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPublicKeyBoxPickyError>(resultPtr);
            Raw.PuttyFfiResultBoxPublicKeyBoxPickyError.Destroy(resultPtr);
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
            Raw.PublicKey* retVal = result.Ok;
            return new PublicKey(retVal);
        }
    }

    /// <summary>
    /// Get the private key from the PPK key file.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PrivateKey</c> allocated on Rust side.
    /// </returns>
    public PrivateKey GetPrivateKey()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            IntPtr resultPtr = Raw.PuttyPpk.GetPrivateKey(_inner);
            Raw.PuttyFfiResultBoxPrivateKeyBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPrivateKeyBoxPickyError>(resultPtr);
            Raw.PuttyFfiResultBoxPrivateKeyBoxPickyError.Destroy(resultPtr);
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
            Raw.PrivateKey* retVal = result.Ok;
            return new PrivateKey(retVal);
        }
    }

    /// <summary>
    /// Extract the public key file (PuTTY format) from the PPK key file.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PuttyPublicKey</c> allocated on Rust side.
    /// </returns>
    public PuttyPublicKey ExtractPuttyPublicKey()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            IntPtr resultPtr = Raw.PuttyPpk.ExtractPuttyPublicKey(_inner);
            Raw.PuttyFfiResultBoxPuttyPublicKeyBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPuttyPublicKeyBoxPickyError>(resultPtr);
            Raw.PuttyFfiResultBoxPuttyPublicKeyBoxPickyError.Destroy(resultPtr);
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
            Raw.PuttyPublicKey* retVal = result.Ok;
            return new PuttyPublicKey(retVal);
        }
    }

    /// <summary>
    /// Get the PPK key file version.
    /// </summary>
    /// <returns>
    /// A <c>PuttyPpkVersion</c> allocated on C# side.
    /// </returns>
    public PuttyPpkVersion GetVersion()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            Raw.PuttyPpkVersion retVal = Raw.PuttyPpk.GetVersion(_inner);
            return (PuttyPpkVersion)retVal;
        }
    }

    /// <summary>
    /// Get the PPK key file algorithm.
    /// </summary>
    /// <returns>
    /// A <c>PuttyPpkKeyAlgorithm</c> allocated on C# side.
    /// </returns>
    public PuttyPpkKeyAlgorithm GetAlgorithm()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            Raw.PuttyPpkKeyAlgorithm retVal = Raw.PuttyPpk.GetAlgorithm(_inner);
            return (PuttyPpkKeyAlgorithm)retVal;
        }
    }

    /// <summary>
    /// Get the PPK key file comment.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    public void GetComment(DiplomatWriteable writeable)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            IntPtr resultPtr = Raw.PuttyPpk.GetComment(_inner, &writeable);
            Raw.PuttyFfiResultVoidBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultVoidBoxPickyError>(resultPtr);
            Raw.PuttyFfiResultVoidBoxPickyError.Destroy(resultPtr);
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
        }
    }

    /// <summary>
    /// Get the PPK key file comment.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    public string GetComment()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            DiplomatWriteable writeable = new DiplomatWriteable();
            IntPtr resultPtr = Raw.PuttyPpk.GetComment(_inner, &writeable);
            Raw.PuttyFfiResultVoidBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultVoidBoxPickyError>(resultPtr);
            Raw.PuttyFfiResultVoidBoxPickyError.Destroy(resultPtr);
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
            string retVal = writeable.ToUnicode();
            writeable.Dispose();
            return retVal;
        }
    }

    /// <summary>
    /// Returns a new PPK key instance with a different comment.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PuttyPpk</c> allocated on Rust side.
    /// </returns>
    public PuttyPpk WithComment(string comment)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            byte[] commentBuf = DiplomatUtils.StringToUtf8(comment);
            nuint commentBufLength = (nuint)commentBuf.Length;
            fixed (byte* commentBufPtr = commentBuf)
            {
                IntPtr resultPtr = Raw.PuttyPpk.WithComment(_inner, commentBufPtr, commentBufLength);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError>(resultPtr);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError.Destroy(resultPtr);
                if (!result.isOk)
                {
                    throw new PickyException(new PickyError(result.Err));
                }
                Raw.PuttyPpk* retVal = result.Ok;
                return new PuttyPpk(retVal);
            }
        }
    }

    /// <summary>
    /// Convert the PPK key file to a different version.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PuttyPpk</c> allocated on Rust side.
    /// </returns>
    public PuttyPpk ToVersion(PuttyPpkVersion version)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            Raw.PuttyPpkVersion versionRaw;
            versionRaw = (Raw.PuttyPpkVersion)version;
            IntPtr resultPtr = Raw.PuttyPpk.ToVersion(_inner, versionRaw);
            Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError>(resultPtr);
            Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError.Destroy(resultPtr);
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
            Raw.PuttyPpk* retVal = result.Ok;
            return new PuttyPpk(retVal);
        }
    }

    /// <summary>
    /// Check if the PPK key file is encrypted.
    /// </summary>
    public bool IsEncrypted()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            bool retVal = Raw.PuttyPpk.IsEncrypted(_inner);
            return retVal;
        }
    }

    /// <summary>
    /// Get the Argon2 key derivation function parameters (if the key is encrypted).
    /// </summary>
    /// <returns>
    /// A <c>PuttyArgon2Params</c> allocated on Rust side.
    /// </returns>
    public PuttyArgon2Params? Argon2Params()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            Raw.PuttyArgon2Params* retVal = Raw.PuttyPpk.Argon2Params(_inner);
            if (retVal == null)
            {
                return null;
            }
            return new PuttyArgon2Params(retVal);
        }
    }

    /// <summary>
    /// Decrypt the PPK key file and return as a new instance.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PuttyPpk</c> allocated on Rust side.
    /// </returns>
    public PuttyPpk Decrypt(string passphrase)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            byte[] passphraseBuf = DiplomatUtils.StringToUtf8(passphrase);
            nuint passphraseBufLength = (nuint)passphraseBuf.Length;
            fixed (byte* passphraseBufPtr = passphraseBuf)
            {
                IntPtr resultPtr = Raw.PuttyPpk.Decrypt(_inner, passphraseBufPtr, passphraseBufLength);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError>(resultPtr);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError.Destroy(resultPtr);
                if (!result.isOk)
                {
                    throw new PickyException(new PickyError(result.Err));
                }
                Raw.PuttyPpk* retVal = result.Ok;
                return new PuttyPpk(retVal);
            }
        }
    }

    /// <summary>
    /// Encrypt the PPK key file and return as a new instance.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PuttyPpk</c> allocated on Rust side.
    /// </returns>
    public PuttyPpk Encrypt(string passphrase, PuttyPpkEncryptionConfig config)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PuttyPpk");
            }
            byte[] passphraseBuf = DiplomatUtils.StringToUtf8(passphrase);
            nuint passphraseBufLength = (nuint)passphraseBuf.Length;
            Raw.PuttyPpkEncryptionConfig* configRaw;
            configRaw = config.AsFFI();
            if (configRaw == null)
            {
                throw new ObjectDisposedException("PuttyPpkEncryptionConfig");
            }
            fixed (byte* passphraseBufPtr = passphraseBuf)
            {
                IntPtr resultPtr = Raw.PuttyPpk.Encrypt(_inner, passphraseBufPtr, passphraseBufLength, configRaw);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError result = Marshal.PtrToStructure<Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError>(resultPtr);
                Raw.PuttyFfiResultBoxPuttyPpkBoxPickyError.Destroy(resultPtr);
                if (!result.isOk)
                {
                    throw new PickyException(new PickyError(result.Err));
                }
                Raw.PuttyPpk* retVal = result.Ok;
                return new PuttyPpk(retVal);
            }
        }
    }

    /// <summary>
    /// Returns the underlying raw handle.
    /// </summary>
    public unsafe Raw.PuttyPpk* AsFFI()
    {
        return _inner;
    }

    /// <summary>
    /// Destroys the underlying object immediately.
    /// </summary>
    public void Dispose()
    {
        unsafe
        {
            if (_inner == null)
            {
                return;
            }

            Raw.PuttyPpk.Destroy(_inner);
            _inner = null;

            GC.SuppressFinalize(this);
        }
    }

    ~PuttyPpk()
    {
        Dispose();
    }
}
