// <auto-generated/> by Diplomat

#pragma warning disable 0105
using System;
using System.Runtime.InteropServices;

using Devolutions.Picky.Diplomat;
#pragma warning restore 0105

namespace Devolutions.Picky;

#nullable enable

/// <summary>
/// A PKCS12 archive.
/// </summary>
public partial class Pfx: IDisposable
{
    private unsafe Raw.Pfx* _inner;

    /// <summary>
    /// Creates a managed <c>Pfx</c> from a raw handle.
    /// </summary>
    /// <remarks>
    /// Safety: you should not build two managed objects using the same raw handle (may causes use-after-free and double-free).
    /// <br/>
    /// This constructor assumes the raw struct is allocated on Rust side.
    /// If implemented, the custom Drop implementation on Rust side WILL run on destruction.
    /// </remarks>
    public unsafe Pfx(Raw.Pfx* handle)
    {
        _inner = handle;
    }

    /// <returns>
    /// A <c>PfxBuilder</c> allocated on Rust side.
    /// </returns>
    public static PfxBuilder Builder(Pkcs12CryptoContext cryptoContext)
    {
        unsafe
        {
            Raw.Pkcs12CryptoContext* cryptoContextRaw;
            cryptoContextRaw = cryptoContext.AsFFI();
            if (cryptoContextRaw == null)
            {
                throw new ObjectDisposedException("Pkcs12CryptoContext");
            }
            Raw.PfxBuilder* retVal = Raw.Pfx.Builder(cryptoContextRaw);
            return new PfxBuilder(retVal);
        }
    }

    /// <summary>
    /// Parses a PKCS12 archive (PFX) from its DER representation.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>Pfx</c> allocated on Rust side.
    /// </returns>
    public static Pfx FromDer(byte[] der, Pkcs12CryptoContext cryptoContext, Pkcs12ParsingParams parsingParams)
    {
        unsafe
        {
            nuint derLength = (nuint)der.Length;
            Raw.Pkcs12CryptoContext* cryptoContextRaw;
            cryptoContextRaw = cryptoContext.AsFFI();
            if (cryptoContextRaw == null)
            {
                throw new ObjectDisposedException("Pkcs12CryptoContext");
            }
            Raw.Pkcs12ParsingParams* parsingParamsRaw;
            parsingParamsRaw = parsingParams.AsFFI();
            if (parsingParamsRaw == null)
            {
                throw new ObjectDisposedException("Pkcs12ParsingParams");
            }
            fixed (byte* derPtr = der)
            {
                IntPtr resultPtr = Raw.Pfx.FromDer(derPtr, derLength, cryptoContextRaw, parsingParamsRaw);
                Raw.Pkcs12FfiResultBoxPfxBoxPickyError result = Marshal.PtrToStructure<Raw.Pkcs12FfiResultBoxPfxBoxPickyError>(resultPtr);
                Raw.Pkcs12FfiResultBoxPfxBoxPickyError.Destroy(resultPtr);
                if (!result.isOk)
                {
                    throw new PickyException(new PickyError(result.Err));
                }
                Raw.Pfx* retVal = result.Ok;
                return new Pfx(retVal);
            }
        }
    }

    /// <summary>
    /// Saves this PKCS12 archive to the filesystem.
    /// </summary>
    /// <exception cref="PickyException"></exception>
    public void SaveToFile(string path)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("Pfx");
            }
            byte[] pathBuf = DiplomatUtils.StringToUtf8(path);
            nuint pathBufLength = (nuint)pathBuf.Length;
            fixed (byte* pathBufPtr = pathBuf)
            {
                IntPtr resultPtr = Raw.Pfx.SaveToFile(_inner, pathBufPtr, pathBufLength);
                Raw.Pkcs12FfiResultVoidBoxPickyError result = Marshal.PtrToStructure<Raw.Pkcs12FfiResultVoidBoxPickyError>(resultPtr);
                Raw.Pkcs12FfiResultVoidBoxPickyError.Destroy(resultPtr);
                if (!result.isOk)
                {
                    throw new PickyException(new PickyError(result.Err));
                }
            }
        }
    }

    /// <summary>
    /// Returns a `SafeBagIterator` to inspect PFX data
    /// </summary>
    /// <returns>
    /// A <c>SafeBagIterator</c> allocated on Rust side.
    /// </returns>
    public SafeBagIterator SafeBags()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("Pfx");
            }
            Raw.SafeBagIterator* retVal = Raw.Pfx.SafeBags(_inner);
            return new SafeBagIterator(retVal);
        }
    }

    /// <summary>
    /// Returns the underlying raw handle.
    /// </summary>
    public unsafe Raw.Pfx* AsFFI()
    {
        return _inner;
    }

    /// <summary>
    /// Destroys the underlying object immediately.
    /// </summary>
    public void Dispose()
    {
        unsafe
        {
            if (_inner == null)
            {
                return;
            }

            Raw.Pfx.Destroy(_inner);
            _inner = null;

            GC.SuppressFinalize(this);
        }
    }

    ~Pfx()
    {
        Dispose();
    }
}
