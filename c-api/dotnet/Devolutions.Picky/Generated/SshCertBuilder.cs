// Automatically generated by Diplomat

#pragma warning disable 0105
using System;
using System.Runtime.InteropServices;

using Devolutions.Picky.Diplomat;
#pragma warning restore 0105

namespace Devolutions.Picky;

#nullable enable

/// <summary>
/// SSH Certificate Builder.
/// </summary>
public partial class SshCertBuilder: IDisposable
{
    private unsafe Raw.SshCertBuilder* _inner;

    public SshCertKeyType CertKeyType
    {
        set
        {
            SetCertKeyType(value);
        }
    }

    public SshCertType CertType
    {
        set
        {
            SetCertType(value);
        }
    }

    public string Comment
    {
        set
        {
            SetComment(value);
        }
    }

    public SshPublicKey Key
    {
        set
        {
            SetKey(value);
        }
    }

    public string KeyId
    {
        set
        {
            SetKeyId(value);
        }
    }

    public ulong Serial
    {
        set
        {
            SetSerial(value);
        }
    }

    public SignatureAlgorithm SignatureAlgo
    {
        set
        {
            SetSignatureAlgo(value);
        }
    }

    public SshPrivateKey SignatureKey
    {
        set
        {
            SetSignatureKey(value);
        }
    }

    public ulong ValidAfter
    {
        set
        {
            SetValidAfter(value);
        }
    }

    public ulong ValidBefore
    {
        set
        {
            SetValidBefore(value);
        }
    }

    /// <summary>
    /// Creates a managed <c>SshCertBuilder</c> from a raw handle.
    /// </summary>
    /// <remarks>
    /// Safety: you should not build two managed objects using the same raw handle (may causes use-after-free and double-free).
    /// </remarks>
    /// <remarks>
    /// This constructor assumes the raw struct is allocated on Rust side.
    /// If implemented, the custom Drop implementation on Rust side WILL run on destruction.
    /// </remarks>
    public unsafe SshCertBuilder(Raw.SshCertBuilder* handle)
    {
        _inner = handle;
    }

    /// <returns>
    /// A <c>SshCertBuilder</c> allocated on Rust side.
    /// </returns>
    public static SshCertBuilder Init()
    {
        unsafe
        {
            Raw.SshCertBuilder* retVal = Raw.SshCertBuilder.Init();
            return new SshCertBuilder(retVal);
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetCertKeyType(SshCertKeyType keyType)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            Raw.SshCertKeyType keyTypeRaw;
            keyTypeRaw = (Raw.SshCertKeyType)keyType;
            Raw.SshCertBuilder.SetCertKeyType(_inner, keyTypeRaw);
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetKey(SshPublicKey key)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            Raw.SshPublicKey* keyRaw;
            keyRaw = key.AsFFI();
            if (keyRaw == null)
            {
                throw new ObjectDisposedException("SshPublicKey");
            }
            Raw.SshCertBuilder.SetKey(_inner, keyRaw);
        }
    }

    /// <summary>
    /// Optional (set to 0 by default)
    /// </summary>
    public void SetSerial(ulong serial)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            Raw.SshCertBuilder.SetSerial(_inner, serial);
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetCertType(SshCertType certType)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            Raw.SshCertType certTypeRaw;
            certTypeRaw = (Raw.SshCertType)certType;
            Raw.SshCertBuilder.SetCertType(_inner, certTypeRaw);
        }
    }

    /// <summary>
    /// Optional
    /// </summary>
    public void SetKeyId(string keyId)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            byte[] keyIdBuf = DiplomatUtils.StringToUtf8(keyId);
            nuint keyIdBufLength = (nuint)keyIdBuf.Length;
            fixed (byte* keyIdBufPtr = keyIdBuf)
            {
                Raw.SshCertBuilder.SetKeyId(_inner, keyIdBufPtr, keyIdBufLength);
            }
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetValidBefore(ulong validBefore)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            Raw.SshCertBuilder.SetValidBefore(_inner, validBefore);
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetValidAfter(ulong validAfter)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            Raw.SshCertBuilder.SetValidAfter(_inner, validAfter);
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetSignatureKey(SshPrivateKey signatureKey)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            Raw.SshPrivateKey* signatureKeyRaw;
            signatureKeyRaw = signatureKey.AsFFI();
            if (signatureKeyRaw == null)
            {
                throw new ObjectDisposedException("SshPrivateKey");
            }
            Raw.SshCertBuilder.SetSignatureKey(_inner, signatureKeyRaw);
        }
    }

    /// <summary>
    /// Optional. RsaPkcs1v15 with SHA256 is used by default.
    /// </summary>
    public void SetSignatureAlgo(SignatureAlgorithm signatureAlgo)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            Raw.SignatureAlgorithm* signatureAlgoRaw;
            signatureAlgoRaw = signatureAlgo.AsFFI();
            if (signatureAlgoRaw == null)
            {
                throw new ObjectDisposedException("SignatureAlgorithm");
            }
            Raw.SshCertBuilder.SetSignatureAlgo(_inner, signatureAlgoRaw);
        }
    }

    /// <summary>
    /// Optional
    /// </summary>
    public void SetComment(string comment)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            byte[] commentBuf = DiplomatUtils.StringToUtf8(comment);
            nuint commentBufLength = (nuint)commentBuf.Length;
            fixed (byte* commentBufPtr = commentBuf)
            {
                Raw.SshCertBuilder.SetComment(_inner, commentBufPtr, commentBufLength);
            }
        }
    }

    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>SshCert</c> allocated on Rust side.
    /// </returns>
    public SshCert Build()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("SshCertBuilder");
            }
            Raw.SshFfiResultBoxSshCertBoxPickyError* resultPtr = Raw.SshCertBuilder.Build(_inner);
            Raw.SshFfiResultBoxSshCertBoxPickyError result = Marshal.PtrToStructure<Raw.SshFfiResultBoxSshCertBoxPickyError>((IntPtr)resultPtr);
            Raw.SshFfiResultBoxSshCertBoxPickyError.Destroy(resultPtr);
            resultPtr = null;
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
            Raw.SshCert* retVal = result.Ok;
            return new SshCert(retVal);
        }
    }

    /// <summary>
    /// Returns the underlying raw handle.
    /// </summary>
    public unsafe Raw.SshCertBuilder* AsFFI()
    {
        return _inner;
    }

    /// <summary>
    /// Destroys the underlying object immediately.
    /// </summary>
    public void Dispose()
    {
        unsafe
        {
            if (_inner == null)
            {
                return;
            }

            Raw.SshCertBuilder.Destroy(_inner);
            _inner = null;

            GC.SuppressFinalize(this);
        }
    }

    ~SshCertBuilder()
    {
        Dispose();
    }
}
