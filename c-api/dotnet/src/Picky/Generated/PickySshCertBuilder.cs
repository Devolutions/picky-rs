// Automatically generated by Diplomat

#pragma warning disable 0105
using System;
using System.Runtime.InteropServices;

using Devolutions.Picky.Diplomat;
#pragma warning restore 0105

namespace Devolutions.Picky;

#nullable enable

/// <summary>
/// SSH Certificate Builder.
/// </summary>
public partial class PickySshCertBuilder: IDisposable
{
    private unsafe Raw.PickySshCertBuilder* _inner;

    public PickySshCertKeyType CertKeyType
    {
        set
        {
            SetCertKeyType(value);
        }
    }

    public PickySshCertType CertType
    {
        set
        {
            SetCertType(value);
        }
    }

    public string Comment
    {
        set
        {
            SetComment(value);
        }
    }

    public PickySshPublicKey Key
    {
        set
        {
            SetKey(value);
        }
    }

    public string KeyId
    {
        set
        {
            SetKeyId(value);
        }
    }

    public ulong Serial
    {
        set
        {
            SetSerial(value);
        }
    }

    public PickySignatureAlgorithm SignatureAlgo
    {
        set
        {
            SetSignatureAlgo(value);
        }
    }

    public PickySshPrivateKey SignatureKey
    {
        set
        {
            SetSignatureKey(value);
        }
    }

    public PickySshTime ValidAfter
    {
        set
        {
            SetValidAfter(value);
        }
    }

    public PickySshTime ValidBefore
    {
        set
        {
            SetValidBefore(value);
        }
    }

    /// <summary>
    /// Creates a managed <c>PickySshCertBuilder</c> from a raw handle.
    /// </summary>
    /// <remarks>
    /// Safety: you should not build two managed objects using the same raw handle (may causes use-after-free and double-free).
    /// </remarks>
    /// <remarks>
    /// This constructor assumes the raw struct is allocated on Rust side.
    /// If implemented, the custom Drop implementation on Rust side WILL run on destruction.
    /// </remarks>
    public unsafe PickySshCertBuilder(Raw.PickySshCertBuilder* handle)
    {
        _inner = handle;
    }

    /// <returns>
    /// A <c>PickySshCertBuilder</c> allocated on Rust side.
    /// If a custom Drop implementation is implemented on Rust side, it WILL run on destruction.
    /// </returns>
    public static PickySshCertBuilder Init()
    {
        unsafe
        {
            Raw.PickySshCertBuilder* retVal = Raw.PickySshCertBuilder.Init();
            return new PickySshCertBuilder(retVal);
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetCertKeyType(PickySshCertKeyType keyType)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            Raw.PickySshCertKeyType keyTypeRaw;
            keyTypeRaw = (Raw.PickySshCertKeyType)keyType;
            Raw.PickySshCertBuilder.SetCertKeyType(_inner, keyTypeRaw);
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetKey(PickySshPublicKey key)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            Raw.PickySshPublicKey* keyRaw;
            keyRaw = key.AsFFI();
            if (keyRaw == null)
            {
                throw new ObjectDisposedException("PickySshPublicKey");
            }
            Raw.PickySshCertBuilder.SetKey(_inner, keyRaw);
        }
    }

    /// <summary>
    /// Optional (set to 0 by default)
    /// </summary>
    public void SetSerial(ulong serial)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            Raw.PickySshCertBuilder.SetSerial(_inner, serial);
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetCertType(PickySshCertType certType)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            Raw.PickySshCertType certTypeRaw;
            certTypeRaw = (Raw.PickySshCertType)certType;
            Raw.PickySshCertBuilder.SetCertType(_inner, certTypeRaw);
        }
    }

    /// <summary>
    /// Optional
    /// </summary>
    public void SetKeyId(string keyId)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            byte[] keyIdBuf = DiplomatUtils.StringToUtf8(keyId);
            nuint keyIdBufLength = (nuint)keyIdBuf.Length;
            fixed (byte* keyIdBufPtr = keyIdBuf)
            {
                Raw.PickySshCertBuilder.SetKeyId(_inner, keyIdBufPtr, keyIdBufLength);
            }
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetValidBefore(PickySshTime validBefore)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            Raw.PickySshTime* validBeforeRaw;
            validBeforeRaw = validBefore.AsFFI();
            if (validBeforeRaw == null)
            {
                throw new ObjectDisposedException("PickySshTime");
            }
            Raw.PickySshCertBuilder.SetValidBefore(_inner, validBeforeRaw);
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetValidAfter(PickySshTime validAfter)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            Raw.PickySshTime* validAfterRaw;
            validAfterRaw = validAfter.AsFFI();
            if (validAfterRaw == null)
            {
                throw new ObjectDisposedException("PickySshTime");
            }
            Raw.PickySshCertBuilder.SetValidAfter(_inner, validAfterRaw);
        }
    }

    /// <summary>
    /// Required
    /// </summary>
    public void SetSignatureKey(PickySshPrivateKey signatureKey)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            Raw.PickySshPrivateKey* signatureKeyRaw;
            signatureKeyRaw = signatureKey.AsFFI();
            if (signatureKeyRaw == null)
            {
                throw new ObjectDisposedException("PickySshPrivateKey");
            }
            Raw.PickySshCertBuilder.SetSignatureKey(_inner, signatureKeyRaw);
        }
    }

    /// <summary>
    /// Optional. RsaPkcs1v15 with SHA256 is used by default.
    /// </summary>
    public void SetSignatureAlgo(PickySignatureAlgorithm signatureAlgo)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            Raw.PickySignatureAlgorithm* signatureAlgoRaw;
            signatureAlgoRaw = signatureAlgo.AsFFI();
            if (signatureAlgoRaw == null)
            {
                throw new ObjectDisposedException("PickySignatureAlgorithm");
            }
            Raw.PickySshCertBuilder.SetSignatureAlgo(_inner, signatureAlgoRaw);
        }
    }

    /// <summary>
    /// Optional
    /// </summary>
    public void SetComment(string comment)
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            byte[] commentBuf = DiplomatUtils.StringToUtf8(comment);
            nuint commentBufLength = (nuint)commentBuf.Length;
            fixed (byte* commentBufPtr = commentBuf)
            {
                Raw.PickySshCertBuilder.SetComment(_inner, commentBufPtr, commentBufLength);
            }
        }
    }

    /// <exception cref="PickyException"></exception>
    /// <returns>
    /// A <c>PickySshCert</c> allocated on Rust side.
    /// If a custom Drop implementation is implemented on Rust side, it WILL run on destruction.
    /// </returns>
    public PickySshCert Build()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            Raw.SshFfiResultBoxPickySshCertBoxPickyError result = Raw.PickySshCertBuilder.Build(_inner);
            if (!result.isOk)
            {
                throw new PickyException(new PickyError(result.Err));
            }
            Raw.PickySshCert* retVal = result.Ok;
            return new PickySshCert(retVal);
        }
    }

    /// <summary>
    /// Returns the underlying raw handle.
    /// </summary>
    public unsafe Raw.PickySshCertBuilder* AsFFI()
    {
        return _inner;
    }

    /// <summary>
    /// Marks this object as moved into Rust side.
    /// </summary>
    public void MarkAsMoved()
    {
        unsafe
        {
            if (_inner == null)
            {
                throw new ObjectDisposedException("PickySshCertBuilder");
            }
            _inner = null;
        }
    }

    /// <summary>
    /// Restores unmanaged ressource handle to this object.
    /// </summary>
    public unsafe void RestoreHandle(Raw.PickySshCertBuilder* handle)
    {
        _inner = handle;
    }

    /// <summary>
    /// Destroys the underlying object immediately.
    /// </summary>
    public void Dispose()
    {
        unsafe
        {
            if (_inner == null)
            {
                return;
            }

            Raw.PickySshCertBuilder.Destroy(_inner);
            _inner = null;

            GC.SuppressFinalize(this);
        }
    }

    ~PickySshCertBuilder()
    {
        Dispose();
    }
}
